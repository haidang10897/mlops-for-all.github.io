<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on</title><link>https://mlops-for-all.github.io/prerequisites/docker/</link><description>Recent content in Docker on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://mlops-for-all.github.io/prerequisites/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Install Docker</title><link>https://mlops-for-all.github.io/prerequisites/docker/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mlops-for-all.github.io/prerequisites/docker/install/</guid><description>Docker # 도커 실습을 위해 도커를 설치해야 합니다.
도커 설치는 어떤 OS를 사용하는지에 따라 달라집니다.
각 환경에 맞는 도커 설치는 공식 홈페이지를 참고해주세요.
ubuntu mac windows 설치 확인 # docker run hello-world 가 정상적으로 수행되는 OS, 터미널 환경이 필요합니다.
OS Docker Engine Terminal MacOS Docker Desktop zsh Windows Docker Desktop Powershell Windows Docker Desktop WSL2 Ubuntu Docker Engine bash 들어가기 앞서서.</description></item><item><title>Why Docker &amp; Kubernetes ?</title><link>https://mlops-for-all.github.io/prerequisites/docker/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mlops-for-all.github.io/prerequisites/docker/introduction/</guid><description>Why Kubernetes ? # 머신러닝 모델을 서비스화하기 위해서는 모델 개발 외에도 많은 부가적인 기능들이 필요합니다.
학습 단계 모델 학습 명령의 스케줄 관리 학습된 모델의 Reproducibility 보장 배포 단계 트래픽 분산 서비스 장애 모니터링 장애 시 트러블슈팅 다행히도 이런 기능들에 대한 needs는 소프트웨어 개발 쪽에서 이미 많은 고민을 거쳐 발전되어 왔습니다.
따라서 머신러닝 모델을 배포할 때도 이런 고민의 결과물들을 활용하면 큰 도움을 받을 수 있습니다.</description></item><item><title>What is Docker?</title><link>https://mlops-for-all.github.io/prerequisites/docker/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mlops-for-all.github.io/prerequisites/docker/docker/</guid><description>컨테이너 # 컨테이너 가상화 어플리케이션을 어디에서나 동일하게 실행하는 기술 컨테이너 이미지 어플리케이션을 실행시키기 위해 필요한 모든 파일들의 집합 → 붕어빵 틀 컨테이너란? 컨테이너 이미지를 기반으로 실행된 한 개의 프로세스 → 붕어빵 틀로 찍어낸 붕어빵 도커 # 도커는 컨테이너를 관리하고 사용할 수 있게 해주는 플랫폼입니다.
이러한 도커의 슬로건은 바로 Build Once, Run Anywhere 로 어디에서나 동일한 실행 결과를 보장합니다.
도커 내부에서 동작하는 과정을 보자면 실제로 container 를 위한 리소스를 분리하고, lifecycle 을 제어하는 기능은 linux kernel 의 cgroup 등이 수행합니다.</description></item><item><title>[Practice] Docker command</title><link>https://mlops-for-all.github.io/prerequisites/docker/command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mlops-for-all.github.io/prerequisites/docker/command/</guid><description>1. 정상 설치 확인 # docker run hello-world 정상적으로 설치된 경우 다음과 같은 메시지를 확인할 수 있습니다.
Hello from Docker! This message shows that your installation appears to be working correctly. .... (For ubuntu) sudo 없이 사용하고 싶다면 아래 사이트를 참고합니다.
https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user 2. Docker Pull # docker image registry(도커 이미지를 저장하고 공유할 수 있는 저장소)로부터 Docker image 를 로컬에 다운로드 받는 커맨드입니다.
아래 커맨드를 통해 docker pull에서 사용 가능한 argument들을 확인할 수 있습니다.</description></item><item><title>[Practice] Docker images</title><link>https://mlops-for-all.github.io/prerequisites/docker/images/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mlops-for-all.github.io/prerequisites/docker/images/</guid><description>1. Dockerfile 만들기 # 도커 이미지를 만드는 가장 쉬운 방법은 도커에서 제공하는 템플릿인 Dockerfile을 사용하는 것입니다.
이외에는 running container 를 docker image 로 만드는 docker commit 등을 활용하는 방법이 있습니다.
Dockerfile 사용자가 도커 이미지를 쉽게 만들 수 있도록, 제공하는 템플릿 파일명은 꼭 Dockerfile 이 아니어도 상관없지만, docker build 수행 시, default 로 사용하는 파일명이 Dockerfile 입니다. 도커 이미지를 만드는 docker build 를 수행할 때, -f 옵션을 주면 다른 파일명으로도 사용 가능합니다.</description></item><item><title>[Practice] Docker Advanced</title><link>https://mlops-for-all.github.io/prerequisites/docker/advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mlops-for-all.github.io/prerequisites/docker/advanced/</guid><description>도커 이미지 잘 만들기 # 도커 이미지를 만들 때 고려해야 될 점 # Dockerfile 을 활용하여 도커 이미지를 만들 때는 명령어의 순서가 중요합니다.
그 이유는 도커 이미지는 여러 개의 Read-Only Layer 로 구성되어있고, 이미지를 빌드할 때 이미 존재하는 레이어는 캐시되어 재사용되기 때문에, 이를 생각해서 Dockerfile 을 구성한다면 빌드 시간을 줄일 수 있습니다.
Dockerfile에서 RUN, ADD, COPY 명령어 하나가 하나의 레이어로 저장됩니다.
예를 들어서 다음과 같은 Dockerfile이 있습니다.
# Layer 1FROMubuntu:latest# Layer 2RUN apt-get update &amp;amp;&amp;amp; apt-get install python3 pip3 -y# Layer 3RUN pip3 install -U pip &amp;amp;&amp;amp; pip3 install torch# Layer 4COPY src/ src/# Layer 5CMD python src/app.</description></item></channel></rss>